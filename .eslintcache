[{"C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\index.tsx":"1","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\reportWebVitals.ts":"2","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\App.tsx":"3","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\AppBar.tsx":"4","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\searching\\SearchingVisualizer.tsx":"5","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\SortingVisualizer.tsx":"6","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\user-tutorial\\UserGuideWindow.tsx":"7","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\pathFinding\\PathFindingVisualizer.tsx":"8","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\sortingAlgorithms\\InsertionSort.ts":"9","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\sortingAlgorithms\\HeapSort.ts":"10","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\sortingAlgorithms\\ShellSort.ts":"11","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\sortingAlgorithms\\SelectionSort.ts":"12","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\searching\\searchingAlgorithms.tsx":"13","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\buttons\\ButtonText.tsx":"14","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\pathFinding\\NodeSquare.tsx":"15","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\pathFinding\\Algorithms.tsx":"16","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\buttons\\ButtonAccent.tsx":"17","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\buttons\\ToggleButton.tsx":"18","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\inputs\\TextField.tsx":"19","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\buttons\\Button.tsx":"20","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\inputs\\slider.tsx":"21","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\sortingAlgorithms\\MergeSort.tsx":"22","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\sortingAlgorithms\\QuickSort.tsx":"23","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\sortingAlgorithms\\template.functions.ts":"24","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\pathFinding\\dijkstra.tsx":"25"},{"size":500,"mtime":1614363306000,"results":"26","hashOfConfig":"27"},{"size":425,"mtime":1614363306000,"results":"28","hashOfConfig":"27"},{"size":1561,"mtime":1614363306000,"results":"29","hashOfConfig":"27"},{"size":1860,"mtime":1629193554686,"results":"30","hashOfConfig":"27"},{"size":10269,"mtime":1614363306000,"results":"31","hashOfConfig":"27"},{"size":7994,"mtime":1614363306000,"results":"32","hashOfConfig":"27"},{"size":4559,"mtime":1629231763093,"results":"33","hashOfConfig":"27"},{"size":12207,"mtime":1614363306000,"results":"34","hashOfConfig":"27"},{"size":3663,"mtime":1614363306000,"results":"35","hashOfConfig":"27"},{"size":4816,"mtime":1614363306000,"results":"36","hashOfConfig":"27"},{"size":2971,"mtime":1614363306000,"results":"37","hashOfConfig":"27"},{"size":4322,"mtime":1614363306000,"results":"38","hashOfConfig":"27"},{"size":3688,"mtime":1614363306000,"results":"39","hashOfConfig":"27"},{"size":498,"mtime":1614363306000,"results":"40","hashOfConfig":"27"},{"size":4169,"mtime":1614363306000,"results":"41","hashOfConfig":"27"},{"size":2930,"mtime":1614363306000,"results":"42","hashOfConfig":"27"},{"size":623,"mtime":1614363306000,"results":"43","hashOfConfig":"27"},{"size":744,"mtime":1614363306000,"results":"44","hashOfConfig":"27"},{"size":558,"mtime":1614363306000,"results":"45","hashOfConfig":"27"},{"size":472,"mtime":1614363306000,"results":"46","hashOfConfig":"27"},{"size":1155,"mtime":1614363306000,"results":"47","hashOfConfig":"27"},{"size":4259,"mtime":1614363306000,"results":"48","hashOfConfig":"27"},{"size":6815,"mtime":1614363306000,"results":"49","hashOfConfig":"27"},{"size":612,"mtime":1614363306000,"results":"50","hashOfConfig":"27"},{"size":3320,"mtime":1614363306000,"results":"51","hashOfConfig":"27"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},"1y8daj9",{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"54"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68","usedDeprecatedRules":"54"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"54"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74","usedDeprecatedRules":"54"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77","usedDeprecatedRules":"54"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"80","usedDeprecatedRules":"54"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83","usedDeprecatedRules":"54"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"86","usedDeprecatedRules":"54"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"91","usedDeprecatedRules":"54"},{"filePath":"92","messages":"93","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"94","usedDeprecatedRules":"54"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"99","messages":"100","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"101","messages":"102","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"105","messages":"106","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"107","usedDeprecatedRules":"54"},{"filePath":"108","messages":"109","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"110","usedDeprecatedRules":"54"},{"filePath":"111","messages":"112","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"113","messages":"114","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"115"},"C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\index.tsx",[],["116","117"],"C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\reportWebVitals.ts",[],"C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\App.tsx",[],"C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\AppBar.tsx",[],"C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\searching\\SearchingVisualizer.tsx",["118","119","120"],"import { useState, useEffect, useRef, memo } from 'react'\nimport { Box } from '@material-ui/core';\nimport TextField from '../../inputs/TextField';\nimport ButtonAccent from '../../buttons/ButtonAccent';\nimport Button from '../../buttons/Button';\nimport getAnimations from './searchingAlgorithms';\n\nfunction SearchingVisualizer()\n{\n   // ---> States\n   const [searchSize, setSearchSize] = useState(200)\n   const [searchItem, setsearchItem] = useState(-1);\n   const [searchArray, setSearchArray] = useState(generateRandom(searchSize));\n   const [searchSpeed, setSearchSpeed] = useState(300);\n   const SortedsearchArray = useRef(sorted());\n\n   const [linearSearchMessage, set_linearSearchMessage] = useState(\"Linear Search\")\n   const [binarySearchMessage, set_binarySearchMessage] = useState(\"Binary Search\")\n   const [linearMessageColor, setLinearMessageColor] = useState(\"white\")\n   const [binaryMessageColor, setBinaryMessageColor] = useState(\"white\")\n   const [timeouts, setTimeouts] = useState([] as any)\n   const [lfound, setlfound] = useState(false)\n   const [bfound, setbfound] = useState(false)\n\n   // -----> UseEffect\n\n   useEffect(() => {\n      SortedsearchArray.current = sorted()\n   }, [searchArray])\n\n\n   // ---> Functions\n\n   function animate(animationFrames: any[], CLASSNAME: string) {\n      let CHANGE_COLOR = 0;\n      let REVERT_COLOR = -1;\n      const numberOfFrames = animationFrames.length;\n\n      for (let x = 0; x < numberOfFrames; x++) {\n         const frame = animationFrames[x];\n         const state = frame.state\n         const steps = frame.steps\n         const index = frame.lookupIndex\n         // const accent = '#0AFFEF';\n         const red = '#dd6f74';\n         if (state === CHANGE_COLOR) executeFrame(CLASSNAME, index, red, x)\n         else if (state === REVERT_COLOR) executeFrame(CLASSNAME, index, red, x)\n         else {\n            executeFrame(CLASSNAME, index, 'yellowgreen', x)\n            if (CLASSNAME === 'linear-bar') {\n               changeMessage('linear-bar', index, steps, x);\n            }\n            else {\n               changeMessage('binary-bar', index, steps, x);\n            }\n            return;\n         }\n      }\n   }\n\n   function changeMessage(CLASSNAME: string, index: number, steps: number, ms: number) {\n      timeouts.push(setTimeout(() => {\n         if (CLASSNAME === 'binary-bar') {\n            setbfound(true);\n            set_binarySearchMessage(`Found at index ${index} in ${steps} steps.`);\n            setBinaryMessageColor('yellowgreen');\n            return;\n         }\n         setlfound(true);\n         set_linearSearchMessage(`Found at index ${index} in ${steps} steps.`);\n         setLinearMessageColor('yellowgreen');\n      }, ms * (301 - searchSpeed)))\n   }\n\n   function executeFrame(CLASSNAME: string, x: number, COLOR: string, ms: number) {\n      timeouts.push(\n         setTimeout(() => {\n            changeColor(CLASSNAME, x, COLOR);\n         }, ms * (301 - searchSpeed)))\n   }\n\n   function changeColor(CLASSNAME: string, index: number, COLOR: string) {\n      const items = (document.getElementsByClassName(CLASSNAME) as HTMLCollectionOf<HTMLElement>)\n      if (items[index]) {\n         items[index].style.backgroundColor = COLOR;\n      }\n   }\n\n   function searchNow() {\n      setlfound(false)\n      setbfound(false)\n      if (searchItem < 0) {\n         alert('Please input a positive integer.')\n         return;\n      }\n\n      for (let x = 0; x < searchArray.length; x++) {\n         changeColor('linear-bar', x, '#0AFFEF')\n         changeColor('binary-bar', x, '#0AFFEF')\n      }\n\n      set_binarySearchMessage('Searching binary...')\n      set_linearSearchMessage('Searching linearly...');\n      setBinaryMessageColor('rgba(255,255,255,.7)')\n      setLinearMessageColor('rgba(255,255,255,.7)')\n\n      let ANIMATIONS = getAnimations(searchArray, searchItem)\n      let LINEAR_ANIMATION = ANIMATIONS[0]\n      let BINARY_ANIMATION = ANIMATIONS[1]\n\n      animate(LINEAR_ANIMATION, 'linear-bar');\n\n      if (LINEAR_ANIMATION.length === searchArray.length * 2) {\n         timeouts.push(setTimeout(() => {\n            set_linearSearchMessage(`Item ${searchItem} not found.`)\n            setLinearMessageColor('red')\n         }, (searchArray.length * 2) * (301 - searchSpeed)))\n      }\n\n      animate(BINARY_ANIMATION, 'binary-bar');\n      let binarySearchWorstTime = (Math.floor(Math.log2(searchArray.length)) * 2);\n\n      if (BINARY_ANIMATION.length === binarySearchWorstTime || BINARY_ANIMATION.length === binarySearchWorstTime+2) {\n         timeouts.push(setTimeout(() => {\n            setbfound(true);\n            set_binarySearchMessage(`Item ${searchItem} not found.`)\n            setBinaryMessageColor('red')\n         }, (binarySearchWorstTime) * (301 - searchSpeed)))\n      }\n   }\n\n   function changeSize(newSize: number) {\n      setSearchSize(newSize);\n      setSearchArray(generateRandom(searchSize));\n   }\n\n   function sorted() {\n      let copy = new Array(searchArray.length)\n      copy = Object.assign([], searchArray)\n      copy = copy.sort((a: number, b: number) => a - b)\n      return copy;\n   }\n\n   function generateRandom(size: number) {\n      let bars = (document.getElementsByClassName('bars') as HTMLCollectionOf<HTMLElement>)\n      const array = [];\n      for (let x = 0; x < size; x++) {\n         const random = Math.floor(Math.random() * (110 - 1 + 1) + 1)\n         array.push(random);\n      }\n      return array;\n   }\n\n\n\n   // ---> MARK UP\n   return (\n      <Box\n         p={4}\n         className=\"flat searchVisualizerContainer \"\n         style={{\n            width: '98vw', height: '80vh', position: 'relative',\n            margin: 'auto', top: '1rem', overflow: 'hidden',\n            borderRadius: '10px'\n         }}>\n         <Box\n            display=\"flex\"\n            className=\"searchItemInput rgba2 transparent\" >\n            <Box\n               margin=\"auto\"\n               flex={1}\n               className=\"transparent\">\n               <Box component=\"span\" mr={1}>Search for :</Box>\n               <TextField\n                  handleInput={(n: number) => {\n                     setsearchItem(n);\n                  }}\n                  type=\"number\"\n                  placeHolder=\"Any positive integer\" />\n            </Box>\n         </Box>\n         <Box\n            className=\"linearSearch rgba2\" >\n            <h3 className=\"searchLabel\" style={{ color: linearMessageColor }} > {linearSearchMessage} </h3>\n            <div>\n               {searchArray.map((each: number, idx: number) =>\n                  <div\n                     style={{ height: `${each}px` }}\n                     key={idx}\n                     className=\"linear-bar\" >\n                  </div>\n               )}\n            </div>\n         </Box>\n         <Box\n            className=\"binarySearch rgba2\" >\n            <h3 className=\"searchLabel\" style={{ color: binaryMessageColor }} > {binarySearchMessage} </h3>\n            <div>\n               {\n                  SortedsearchArray.current.map((each: number, idx: number) =>\n                     <div\n                        style={{ height: `${each}px` }}\n                        key={idx}\n                        className=\"binary-bar\">\n                     </div>\n                  )}\n            </div>\n         </Box>\n         <Box\n            className=\"searchingVisualizerPanel rgba2\" >\n            <div>\n               <Box\n                  ml={2} mr={2}>\n                  <Button label=\"New Array\" handleClick={() => {\n                     setSearchArray(generateRandom(searchSize))\n                     for (let x = 0; x < searchArray.length; x++) {\n                        changeColor('linear-bar', x, '#0AFFEF')\n                        changeColor('binary-bar', x, '#0AFFEF')\n                     }\n                     setLinearMessageColor(\"white\")\n                     setBinaryMessageColor(\"white\")\n                     set_binarySearchMessage(\"Binary Search\")\n                     set_linearSearchMessage(\"Linear Search\")\n                  }} />\n               </Box>\n               <Box\n                  ml={2} mr={2}\n                  display=\"flex\"\n                  flexDirection=\"column\"\n                  alignItems=\"center\"\n                  justifyContent=\"center\">\n                  <Box p={1} >Change Size</Box>\n                  <input\n                     id=\"searchArray-change-size-slider\"\n                     type=\"range\"\n                     onInput={(event: any) => { changeSize(event.target.value) }}\n                     value={searchSize}\n                     min={10}\n                     max={300} />\n               </Box>\n               <Box\n                  ml={2} mr={2}\n                  display=\"flex\"\n                  flexDirection=\"column\"\n                  alignItems=\"center\"\n                  justifyContent=\"center\">\n                  <Box p={1}>Change Speed</Box>\n                  <input\n                     id=\"searchArray-change-speed-slider\"\n                     type=\"range\"\n                     value={searchSpeed}\n                     onInput={(event: any) => { setSearchSpeed(event.target.value) }}\n                     min={10}\n                     max={200} />\n               </Box>\n               <Box\n                  ml={2} mr={2}>\n                  <ButtonAccent\n                     type=\"accent\"\n                     label=\"Search\"\n                     handleClick={searchNow} />\n               </Box>\n               <Box\n                  ml={2} mr={2}>\n                  <ButtonAccent\n                     type=\"error\"\n                     label=\"stop\"\n                     handleClick={() => {\n                        for (const each of timeouts) {\n                           clearTimeout(each);\n                        }\n                        if (!lfound) {\n                           set_linearSearchMessage(\"Search stopped.\")\n                           setLinearMessageColor('yellow')\n                        }\n                        if (!bfound) {\n                           set_binarySearchMessage(\"Search stopped.\")\n                           setBinaryMessageColor('yellow')\n                        }\n                     }} />\n               </Box>\n            </div>\n         </Box>\n      </Box>\n   )\n}\nexport default memo(SearchingVisualizer);","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\SortingVisualizer.tsx",[],"C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\user-tutorial\\UserGuideWindow.tsx",["121"],"import {Box} from '@material-ui/core';\nimport {useState, useRef} from 'react';\n\nimport one from '../../assets/tutorials/one.mp4';\nimport two from '../../assets/tutorials/two.mp4';\nimport three from '../../assets/tutorials/three.mp4';\nimport four from '../../assets/tutorials/four.mp4';\nimport five from '../../assets/tutorials/five.mp4';\nimport six from '../../assets/tutorials/six.mp4';\nimport seven from '../../assets/tutorials/seven.mp4';\nimport eight from '../../assets/tutorials/eight.mp4';\nimport nine from '../../assets/tutorials/nine.mp4';\n\n\nexport default function UserGuideWindow (props: any) {\n\n    const [TUTORIAL_INTRO, SET_TUTORIAL_INTRO] = useState(true);\n\n    const TUTORIAL_DATA = useRef([\n        {\n            id: 0,\n            title: 'First, pick a sorting algorithm.',\n            source: one\n        },\n        {\n            id: 1,\n            title: \"Then, click sort to visualize the algorithm. Wait until it's  finish.\",\n            source: two\n        },\n        {\n            id: 2,\n            title: \"Once it's done, you can generate new array and pick another algorithm.\",\n            source: three\n        },\n        {\n            id: 3,\n            title: \"If you want a smaller or larger array, you can change its size or length.\",\n            source: four\n        },\n        {\n            id: 4,\n            title: \"If you want to visualize the algorithm clearly, make it slower by changing the sorting speed.\",\n            source: five\n        },\n        {\n            id: 5,\n            title: \"You can also change the order of arrangement to ascending or descending.\",\n            source: six\n        },\n        {\n            id: 6,\n            title: \"Now, let's move on to Searching Visualizer Tab\",\n            source: seven\n        },\n        {\n            id: 7,\n            title: \"Type an integer to be search, change the speed then click search.\",\n            source: eight\n        },\n        {\n            id: 8,\n            title: \"If linear search is too slow. Click stop\",\n            source: nine\n        },\n    ]);\n\n    const [ACTIVE_WINDOW, SET_ACTIVE_WINDOW] = useState(TUTORIAL_DATA.current[0]);\n\n    function changeWindow (n: number) {\n        const max = TUTORIAL_DATA.current.length;\n        const newIndex = ACTIVE_WINDOW.id + n;\n\n        if (newIndex < 0) SET_TUTORIAL_INTRO(true);\n        else if (newIndex === max) props.handleSkip();\n        else {\n            SET_ACTIVE_WINDOW(TUTORIAL_DATA.current[newIndex]);\n        }\n    }\n\n    function handleCheckBox (e: any) {\n        if (e.target.checked == true) {\n            localStorage.setItem('tutorialHidden', \"true\");\n        }\n    }\n\n    return (\n        <>\n            <Box hidden={!TUTORIAL_INTRO}>\n                <div className=\"user-guide-window\">\n                    <h1>Thank You!</h1>\n                    <h2>For Visiting Algo Visualizer</h2>\n                    <p>\n                        This visualization tool is designed to help beginner programmers\n                        visualize fundamental sorting, searching and visualizing an arbitrary code.\n                        Please take the short tutorial first if you're not yet familiar,\n                        otherwise, just skip.\n                    </p>\n                    <div>\n                        <button onClick={() => {SET_TUTORIAL_INTRO(false);}} >Start tutorial</button>\n                        <button onClick={props.handleSkip}>Skip for now</button>\n                    </div>\n                    <div className=\"dont-show-again\">\n                        <input type=\"checkbox\" id=\"checkbox-dont-show-again\" onClick={handleCheckBox} />\n                        &nbsp; Dont' show again\n                    </div>\n                </div>\n            </Box>\n\n            <Box hidden={TUTORIAL_INTRO}>\n                <div className=\"tutorials\">\n                    <span id=\"counter\"> {ACTIVE_WINDOW.id + 1}/{TUTORIAL_DATA.current.length} </span>\n                    <h1> {ACTIVE_WINDOW.title} </h1>\n                    <div className=\"content-container\">\n                        <video src={ACTIVE_WINDOW.source} loop autoPlay muted />\n                    </div>\n                    <div>\n                        <button className=\"tutorialbtn\" onClick={() => {changeWindow(-1);}} >back</button>\n                        <button className=\"tutorialbtn\" onClick={() => {changeWindow(1);}}> {(ACTIVE_WINDOW.id === TUTORIAL_DATA.current.length - 1 ? 'Finish' : 'Next')} </button>\n                    </div>\n                </div>\n            </Box>\n        </>\n    );\n}","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\pathFinding\\PathFindingVisualizer.tsx",["122","123","124","125"],"import React, {createContext, useEffect} from 'react';\nimport ArrowDropDownIcon from '@material-ui/icons/ArrowDropDown';\nimport NodeSquare from './NodeSquare';\nimport {Box} from '@material-ui/core';\nimport Button from '../../buttons/Button';\nimport ButtonAccent from '../../buttons/ButtonAccent';\nimport {useState, useRef, useMemo} from 'react';\nimport Algorithms, {bfs, node} from './Algorithms';\n\nexport const mouseDownContext = createContext({} as any);\n\nfunction PathFindingVisualizer () {\n    let boxes = (document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>);\n    const [algoOptionsDropdown, set_algoOptionsDropdown] = useState(false);\n    const [activeAlgo, setActiveAlgo] = useState({id: -1, name: 'Choose Algorithm'});\n    const [speed, setSpeed] = useState(93);\n\n    const algortihms = useRef([\n        {id: 0, name: 'Breadth First Search'},\n        {id: 1, name: 'Depth First Search'},\n        {id: 2, name: 'Dijkstra\\'s Algorithm'},\n    ]);\n\n    useEffect(() => {\n        addBorderWalls();\n    }, []);\n\n    const [nodes, setNodes] = useState([] as any);\n    const [start, setStart] = useState(105);\n    const [finish, setFinish] = useState(645);\n    const [prevNode, setPrevNode] = useState(-1);\n\n    const [isMouseDown, set_isMouseDown] = useState(false);\n\n    useMemo(() => {\n        const hey = [] as any;\n        for (let x = 0; x < 50 * 15; x++) {\n            hey.push(<NodeSquare\n                clearPath={clearPath}\n                onMouseEnter={findThePath}\n                changeStart={handleChangeStart}\n                changeFinish={handleChangeFinish}\n                changePrev={(id: number) => {setPrevNode(id);}}\n                onMouseDown={(b: boolean) => {set_isMouseDown(b);}}\n                isStart={x === start}\n                isFinish={x === finish}\n                id={x}\n                key={x} />);\n        }\n        setNodes(hey);\n    }, [start, finish, activeAlgo]);\n\n    // FUNCTIONS @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    function findThePath (s: number, en: number, instant?: boolean) {\n        if (instant) {\n            const frames = Algorithms(en, s, activeAlgo.id)[1];\n            for (let x = 0; x < frames.length; x++) {\n                if (frames[x] === finish) break;\n                if (boxes[frames[x]]) {\n                    boxes[frames[x]].classList.add('path');\n                }\n            }\n            return;\n        }\n        clearPath();\n        clearVisited();\n        // this will accept two array\n        let animationFrames = Algorithms(en, s, activeAlgo.id);\n        animate(animationFrames[0], 'visited');\n        setTimeout(() => {\n            animatePath(animationFrames[1]);\n            setTimeout(() => {\n                clearVisited();\n            }, animationFrames[1].length * (120 - speed));\n        }, animationFrames[0].length * (100 - speed));\n    }\n\n    function animate (frames: number[], classname: string) {\n        for (let x = 0; x < frames.length; x++) {\n            if (frames[x] === start) continue;\n            changeColor(frames[x], x, classname);\n        }\n    }\n    function animatePath (frames: number[]) {\n        for (let x = 0; x < frames.length; x++) {\n            if (frames[x] === finish) continue;\n            changeColor(frames[x], x * 4, 'path');\n        }\n        if (boxes[frames[frames.length - 1]] === undefined) {\n            window.alert('There is no possible path.');\n        }\n    }\n\n    function changeColor (id: number, ms: number, classname: string) {\n        setTimeout(() => {\n            if (classname === 'path') {\n                boxes[id].classList.remove('visited');\n                boxes[id].classList.add(classname);\n            }\n            else if (boxes[id]) {\n                if (id === finish) return;\n                boxes[id].classList.add(classname);\n            }\n        }, ms * (100 - speed));\n    }\n    function addBorderWalls () {\n        for (let x = 0; x < 50; x++) {\n            if (boxes[x])\n                boxes[x].style.transition = \".1s ease-in\";\n            boxes[x].classList.add('obstacle');\n        }\n        for (let x = 50; x < (50 * 15); x += 50) {\n            if (boxes[x])\n                boxes[x].style.transition = \".1s ease-in\";\n            boxes[x].classList.add('obstacle');\n        }\n        for (let x = 99; x < (50 * 15); x += 50) {\n            if (boxes[x])\n                boxes[x].style.transition = \".1s ease-in\";\n            boxes[x].classList.add('obstacle');\n        }\n        for (let x = 50 * 14; x < (50 * 15); x++) {\n            if (boxes[x])\n                boxes[x].style.transition = \".1s ease-in\";\n            boxes[x].classList.add('obstacle');\n        }\n    }\n    function handleChangeStart (n: number) {\n        setStart(n);\n    }\n    function handleChangeFinish (n: number) {\n        setFinish(n);\n    }\n    const ShowAlgoOptionsDropdown = () => {\n        set_algoOptionsDropdown((prev: boolean) => !prev);\n    };\n    const selectAlgo = (id: number) => {\n        setActiveAlgo(algortihms.current[id]);\n        set_algoOptionsDropdown(false);\n    };\n    function changeSpeed (e: any) {\n        const value = e.target.value;\n        setSpeed(value);\n    }\n    function clearObstacles () {\n        let boxes = document.querySelectorAll('.obstacle');\n        for (let x = 0; x < boxes.length; x++) {\n            boxes[x].classList.remove('obstacle');\n        }\n    }\n    function clearPath () {\n        let boxes = document.querySelectorAll('.path');\n        for (let x = 0; x < boxes.length; x++) {\n            boxes[x].classList.remove('path');\n        }\n    }\n    function clearVisited () {\n        let boxes = document.querySelectorAll('.visited');\n        for (let x = 0; x < boxes.length; x++) {\n            boxes[x].classList.remove('visited');\n        }\n    }\n    function clearWeights () {\n        let boxes = document.querySelectorAll('.weight');\n        for (let x = 0; x < boxes.length; x++) {\n            boxes[x].classList.remove('weight');\n        }\n    }\n    function resetField () {\n        setActiveAlgo({id: -1, name: \"Choose Algorithm\"});\n        clearObstacles();\n        clearPath();\n        clearVisited();\n        clearWeights();\n        addBorderWalls();\n    }\n    function generateWalls () {\n        clearObstacles();\n        addBorderWalls();\n        clearPath();\n        for (let x = 0; x < 50 * 15; x++) {\n            if (boxes[x] && !(boxes[x].classList.contains('obstacle')) && !(boxes[x].classList.contains('finish')) && !(boxes[x].classList.contains('start'))) {\n                if (Math.floor(Math.random() * 50) < 14)\n                    boxes[x].classList.add('obstacle');\n            }\n        }\n    }\n    // OTHER VARIABLES @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    const algoOptions = algortihms.current.map((each: any) =>\n        <div key={each.id} onClick={() => {\n            (document.getElementsByClassName(\"pathfinding-algoOptions\") as HTMLCollectionOf<HTMLElement>)[0].style.border = \"none\";\n            selectAlgo(each.id);\n        }} > {each.name} </div>\n    );\n\n    // function isObstacle(index: number) {\n    //     return (boxes[index] !== undefined && boxes[index].classList.contains('obstacle'));\n    // }\n    function makeObstacle (index: number) {\n        if (boxes[index] && !(boxes[index].classList.contains('finish')) && !(boxes[index].classList.contains('start'))) boxes[index].classList.add('obstacle');\n    }\n\n    function createMaze (start: number, length: number, height: number, first?: boolean) {\n        if (length < 2 || height < 3) return;\n        if (first) {\n            clearPath();\n            clearObstacles();\n            addBorderWalls();\n        }\n\n        let halfLen = Math.floor(length / 2);\n        let halfHeight = Math.floor(height / 2);\n\n        // horizontal mid node\n        let lmid = start + halfLen;\n        // vertical mid node\n        let hmid = start + (50 * halfHeight);\n\n        let randomX = Math.floor(Math.random() * halfHeight + 1);\n        for (let x = 0; x < halfHeight; x++) {\n            if (x === randomX || x === randomX - 1) continue;\n            makeObstacle(lmid + (50 * x));\n        }\n        let remainingY = (height - halfHeight);\n        randomX = Math.floor(Math.random() * remainingY);\n        for (let x = 0; x < remainingY; x++) {\n            if (x === randomX || x === randomX - 1) continue;\n            makeObstacle((lmid + (50 * halfHeight) + (x * 50)));\n        }\n\n        let randomY = Math.floor(Math.random() * halfLen + 1);\n\n        for (let x = 0; x < halfLen; x++) {\n            if (x === randomY || randomY - 1 === x || randomY + 1 === x) continue;\n            makeObstacle(hmid + x);\n        }\n        let remainingX = length - halfLen;\n        randomY = Math.floor(Math.random() * remainingX);\n        for (let x = 0; x < remainingX; x++) {\n            if (x === randomY || randomY - 1 === x || randomY + 1 === x) continue;\n            makeObstacle(hmid + x + halfLen);\n        }\n\n        createMaze(start, halfLen, halfHeight);\n        createMaze(start + halfLen - 1, remainingX, halfHeight);\n        createMaze(hmid + 100, halfLen, remainingY);\n        createMaze(hmid + 100 + halfLen, remainingX, remainingY);\n    }\n\n\n    // MARK UP @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    return (\n        <Box\n            p={4}\n            className=\"flat\"\n            style={{\n                width: '98vw', height: '80vh', position: 'relative',\n                margin: 'auto', top: '1rem', overflow: 'hidden',\n                borderRadius: '10px'\n            }}>\n\n            <div className={\"pathfinding-algoOptions\"}>\n                <div className=\"pathfinding-algo-dropdown\" onClick={ShowAlgoOptionsDropdown}>\n                    <div> {activeAlgo.name} </div>\n                    <ArrowDropDownIcon />\n                </div>\n\n                <Box hidden={!algoOptionsDropdown}>\n                    <div className=\"pathAlgo-options\">\n                        {algoOptions}\n                    </div>\n                </Box>\n            </div>\n\n            <div className=\"search-field\">\n                <mouseDownContext.Provider value={{MouseDown: isMouseDown, prev: prevNode, s: start, f: finish}}>\n                    <div id=\"draggable-field\" >\n                        {nodes}\n                    </div>\n                </mouseDownContext.Provider>\n            </div>\n\n            <div className=\"pathFinding-panel\">\n                <div>\n                    <Box pl={2} pr={2} display=\"flex\" flexDirection=\"column\" alignItems=\"center\">\n                        <Box m={1}>Change Speed</Box>\n                        <input aria-label=\"pathfinding-speed\" type=\"range\" min={0.1} max={98} value={speed} onChange={changeSpeed} />\n                    </Box>\n                    <Box pl={2} pr={2} display=\"flex\" flexDirection=\"column\" alignItems=\"center\">\n                        <Button label=\"Reset Field\" handleClick={resetField} />\n                    </Box>\n                    <Box pl={2} pr={2} display=\"flex\" flexDirection=\"column\" alignItems=\"center\">\n                        <Button label=\"Random Walls\" handleClick={generateWalls} />\n                    </Box>\n                    <Box pl={2} pr={2} display=\"flex\" flexDirection=\"column\" alignItems=\"center\">\n                        <Button label=\"Create Maze\" handleClick={() => {createMaze(51, 48, 13, true);}} />\n                    </Box>\n                    <Box pl={2} pr={2} display=\"flex\" flexDirection=\"column\" alignItems=\"center\">\n                        <ButtonAccent handleClick={() => {\n                            if (activeAlgo.id === -1) {\n                                (document.getElementsByClassName(\"pathfinding-algoOptions\") as HTMLCollectionOf<HTMLElement>)[0].style.border = \"2px solid red\";\n                                return;\n                            }\n                            (document.getElementsByClassName(\"pathfinding-algoOptions\") as HTMLCollectionOf<HTMLElement>)[0].style.border = \"none\";\n                            findThePath(start, finish, false);\n                        }} type=\"error\" label=\"Find the path!\" />\n                    </Box>\n                </div>\n            </div>\n        </Box>\n    );\n}\n\nexport default React.memo(PathFindingVisualizer);","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\sortingAlgorithms\\InsertionSort.ts",["126"],"import {\n    changeColor,\n    changeHeight,\n    ACC, RED, PURPLE, GREEN\n}\n    from './template.functions'\n\n// ======================================= dependent Variables\nlet ANIMATION_SPEED = 40;\nlet mainArray = [] as any;\n// containers of Animation Sequence\nlet animations = [] as any;\n\n// ======================================= constants \n// this will be use for identifyig \n// animation sequences\nconst CHANGE = \"change\";\nconst REVERT = \"revert\";\nconst SWAP_CHANGE = \"swap_change\";\nconst SWAP_REVERT = \"swap_revert\";\n\n// =========================================== ANIMATE\n\nfunction animate() {\n    \n    for (let x = 0; x < animations.length; x++) {\n        const STATE = animations[x][0];\n        const VALUE_1 = animations[x][1];\n        const VALUE_2 = animations[x][2];\n        if (STATE === CHANGE) {\n            setTimeout(() => {\n                changeColor(VALUE_1, PURPLE);\n                changeColor(VALUE_2, RED);\n            }, x * ANIMATION_SPEED);\n        }\n        else if (STATE === REVERT) {\n            setTimeout(() => {\n                changeColor(VALUE_1, ACC);\n                changeColor(VALUE_2, ACC);\n            }, x * ANIMATION_SPEED);\n        }\n        else if (STATE === SWAP_CHANGE) {\n            setTimeout(() => {\n                changeColor(VALUE_1, GREEN);\n                changeColor(VALUE_2, GREEN);\n                changeHeight(VALUE_1, mainArray[VALUE_1]);\n                changeHeight(VALUE_2, mainArray[VALUE_2]);\n            }, x * ANIMATION_SPEED);\n        }\n        else {\n            setTimeout(() => {\n                changeColor(VALUE_1, ACC);\n                changeColor(VALUE_2, ACC);\n            }, x * ANIMATION_SPEED);\n        }\n    }\n}\n\n\n// =========================================== ENTRY POINT\nexport default function InsertionSort(\n    nums: number[],\n    speed: number,\n    descending: boolean,\n    callback: Function,\n    returnFrames?: boolean) \n{\n    mainArray = new Array(nums.length)\n    mainArray = Object.assign([], nums )\n\n    ANIMATION_SPEED = 200 - speed;\n    animations = [];\n\n    // actual algo\n    let size = mainArray.length;\n    for (let x = 1; x < size; x++)\n    {\n        animations.push([CHANGE, x, x-1])\n        animations.push([REVERT, x, x-1])\n\n        if (!descending) {\n            if (mainArray[x - 1] > mainArray[x])\n            {\n                for (let y = x; y > 0; y--)\n                {\n                    animations.push([CHANGE, y, y-1])\n                    animations.push([REVERT, y, y-1])\n\n                    if (mainArray[y] < mainArray[y - 1]) {\n\n                        animations.push([SWAP_CHANGE, y, y-1])\n                        animations.push([SWAP_REVERT, y, y-1])\n\n                        const temp = mainArray[y];\n                        mainArray[y] = mainArray[y - 1]\n                        mainArray[y - 1] = temp\n                    }\n                }\n            }            \n        }\n        else {\n            if (mainArray[x - 1] < mainArray[x])\n            {\n                for (let y = x; y > 0; y--)\n                {\n                    animations.push([CHANGE, y, y-1])\n                    animations.push([REVERT, y, y-1])\n\n                    if (mainArray[y] > mainArray[y - 1]) {\n\n                        animations.push([SWAP_CHANGE, y, y-1])\n                        animations.push([SWAP_REVERT, y, y-1])\n\n                        const temp = mainArray[y];\n                        mainArray[y] = mainArray[y - 1]\n                        mainArray[y - 1] = temp\n                    }\n                }\n            }\n        }\n    }\n\n    if (returnFrames) return animations;\n    animate();\n    callback(animations.length)\n}\n    ","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\sortingAlgorithms\\HeapSort.ts",["127"],"import {\n    changeColor,\n    changeHeight,\n    ACC, RED, PURPLE, GREEN\n}\n    from './template.functions'\n\n// ======================================= dependent Variables\nlet mainArray = [] as number[];\n// this will be updated using the props\nlet ANIMATION_SPEED = 40;\n// containers of Animation Sequence\nlet animations = [] as any;\nlet isDescending = false;\n\n// ======================================= constants Variables\n// this will be use for identifyig \n// animation sequences\nconst CHANGE = \"change\";\nconst REVERT = \"revert\";\nconst SWAP_CHANGE = \"swap_change\";\nconst SWAP_REVERT = \"swap_revert\";\n\n// ======================================= ENTRY POINT\nexport default function HeapSort(\n    numbers: number[],\n    animation_speed: number,\n    descending: boolean,\n    callback: Function,\n    returnFrames?: boolean\n)\n{\n    ANIMATION_SPEED = 200 - animation_speed;\n    isDescending = descending;\n    mainArray = Object.assign([], numbers);\n    animations = [];\n    // actual call of heapsort algorithm\n    sort();\n    if (returnFrames) return animations;\n    // animate\n    animate();\n    callback(animations.length)\n}\n\n// ======================================== animation \nfunction animate() {\n    \n    for (let x = 0; x < animations.length; x++) {\n        const STATE = animations[x][0];\n        const VALUE_1 = animations[x][1];\n        const VALUE_2 = animations[x][2];\n        if (STATE === CHANGE) {\n            setTimeout(() => {\n                changeColor(VALUE_1, PURPLE);\n                changeColor(VALUE_2, RED);\n            }, x * ANIMATION_SPEED);\n        }\n        else if (STATE === REVERT) {\n            setTimeout(() => {\n                changeColor(VALUE_1, ACC);\n                changeColor(VALUE_2, ACC);\n            }, x * ANIMATION_SPEED);\n        }\n        else if (STATE === SWAP_CHANGE) {\n            setTimeout(() => {\n                changeColor(VALUE_1, GREEN);\n                changeColor(VALUE_2, GREEN);\n                changeHeight(VALUE_1, mainArray[VALUE_1]);\n                changeHeight(VALUE_2, mainArray[VALUE_2]);\n            }, x * ANIMATION_SPEED);\n        }\n        else {\n            setTimeout(() => {\n                changeColor(VALUE_1, ACC);\n                changeColor(VALUE_2, ACC);\n            }, x * ANIMATION_SPEED);\n        }\n    }\n}\n\n\n// ======================================== Sort\nfunction sort() {\n    let halfSize = mainArray.length / 2;\n    halfSize = Math.floor(halfSize);\n    \n    for (let x = halfSize; x >= 0; x--) {\n        heapify(mainArray.length, x);\n    }\n    for (let x = mainArray.length - 1; x > 0; x--)\n    {\n        animations.push([SWAP_CHANGE, x, 0])\n        animations.push([SWAP_REVERT, x, 0])\n        const temp = mainArray[0];\n        mainArray[0] = mainArray[x]\n        mainArray[x] = temp;\n        heapify(x, 0);\n    }\n}\n\nfunction heapify(size: number, root: number) {\n    if (root >= size)\n        return;\n\n    let left = (2 * root) + 1;\n    let right = (2 * root) + 2;\n\n    if (left < size) {\n        // comparision\n        animations.push([CHANGE, left, root])\n        animations.push([REVERT, left, root])\n\n        if (!isDescending) {\n            if (mainArray[left] > mainArray[root]) {    \n\n                animations.push([SWAP_CHANGE, left, root])\n                animations.push([SWAP_REVERT, left, root])\n\n                const temp = mainArray[left];\n                mainArray[left] = mainArray[root];\n                mainArray[root] = temp;\n            }    \n        }\n        else {\n            if (mainArray[left] < mainArray[root]) {\n\n                animations.push([SWAP_CHANGE, left, root])\n                animations.push([SWAP_REVERT, left, root])\n               \n                const temp = mainArray[left];\n                mainArray[left] = mainArray[root];\n                mainArray[root] = temp;\n            }\n        }\n            \n    }\n    if (right < size) {\n        // comparision\n        animations.push([CHANGE, right, root])\n        animations.push([REVERT, right, root])\n        if (!isDescending) {\n          \n            if (mainArray[right] > mainArray[root]) {\n\n                animations.push([SWAP_CHANGE, right, root])\n                animations.push([SWAP_REVERT, right, root])\n               \n                const temp = mainArray[right];\n                mainArray[right] = mainArray[root];\n                mainArray[root] = temp;\n            }\n        }\n        else {\n            if (mainArray[right] < mainArray[root]) {\n\n                animations.push([SWAP_CHANGE, right, root])\n                animations.push([SWAP_REVERT, right, root])\n                \n                const temp = mainArray[right];\n                mainArray[right] = mainArray[root];\n                mainArray[root] = temp;\n            }\n        }\n    }\n    heapify(size, left);\n    heapify(size, right);\n}","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\sortingAlgorithms\\ShellSort.ts",["128"],"import {\n    changeColor,\n    changeHeight,\n    ACC, RED, PURPLE, GREEN\n}\n    from './template.functions'\n\n// ======================================= dependent Variables\nlet ANIMATION_SPEED = 40;\nlet mainArray = [] as any;\n// containers of Animation Sequence\nlet animations = [] as any;\n\n// ======================================= constants \n// this will be use for identifyig \n// animation sequences\nconst CHANGE = \"change\";\nconst REVERT = \"revert\";\nconst SWAP_CHANGE = \"swap_change\";\nconst SWAP_REVERT = \"swap_revert\";\n\n// =========================================== ANIMATE\n\nfunction animate() {\n    \n    for (let x = 0; x < animations.length; x++) {\n        const STATE = animations[x][0];\n        const VALUE_1 = animations[x][1];\n        const VALUE_2 = animations[x][2];\n        if (STATE === CHANGE) {\n            setTimeout(() => {\n                changeColor(VALUE_1, PURPLE);\n                changeColor(VALUE_2, RED);\n            }, x * ANIMATION_SPEED);\n        }\n        else if (STATE === REVERT) {\n            setTimeout(() => {\n                changeColor(VALUE_1, ACC);\n                changeColor(VALUE_2, ACC);\n            }, x * ANIMATION_SPEED);\n        }\n        else if (STATE === SWAP_CHANGE) {\n            setTimeout(() => {\n                changeColor(VALUE_1, GREEN);\n                changeColor(VALUE_2, GREEN);\n                changeHeight(VALUE_1, mainArray[VALUE_1]);\n                changeHeight(VALUE_2, mainArray[VALUE_2]);\n            }, x * ANIMATION_SPEED);\n        }\n        else {\n            setTimeout(() => {\n                changeColor(VALUE_1, ACC);\n                changeColor(VALUE_2, ACC);\n            }, x * ANIMATION_SPEED);\n        }\n    }\n}\n\n\n// =========================================== ENTRY POINT\nexport default function ShellSort(\n    nums: number[],\n    speed: number,\n    descending: boolean,\n    callback: Function,\n    returnFrames?: boolean )\n{\n    mainArray = new Array(nums.length)\n    mainArray = Object.assign([], nums )\n\n    ANIMATION_SPEED = 200 - speed;\n    animations = [];\n\n    // actual algo\n    let gap = Math.floor(mainArray.length / 2);\n    while ( gap >= 1) {\n        for (let j = gap; j < mainArray.length; j++) {\n            for (let i = j - gap; i >= 0; i -= gap) {\n\n                animations.push([CHANGE, i+gap, i])\n                animations.push([REVERT, i+gap, i])\n\n                if (!descending) {\n                    if (mainArray[i + gap] > mainArray[i]) break;    \n                }else\n                    if (mainArray[i + gap] < mainArray[i]) break;    \n                \n                animations.push([SWAP_CHANGE, i+gap, i])\n                animations.push([SWAP_REVERT, i+gap, i])\n\n                const temp = mainArray[i + gap]\n                mainArray[i + gap] = mainArray[i]\n                mainArray[i] = temp;\n            }\n        }\n        gap = Math.floor(gap / 2)\n    }\n\n    if (returnFrames) return animations;\n    animate();\n    callback(animations.length);\n}","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\sortingAlgorithms\\SelectionSort.ts",["129"],"import {\n    changeColor,\n    changeHeight,\n    ACC, RED, PURPLE, GREEN\n}\n    from './template.functions'\n\n// ======================================= dependent Variables\nlet ANIMATION_SPEED = 40;\nlet mainArray = [] as any;\n// containers of Animation Sequence\nlet animations = [] as any;\n\n// ======================================= constants \n// this will be use for identifyig \n// animation sequences\nconst CHANGE = \"change\";\nconst REVERT = \"revert\";\nconst SWAP_CHANGE = \"swap_change\";\nconst SWAP_REVERT = \"swap_revert\";\n\n// =========================================== ANIMATE\n\nfunction animate() {\n    \n    for (let x = 0; x < animations.length; x++) {\n        const STATE = animations[x][0];\n        const VALUE_1 = animations[x][1];\n        const VALUE_2 = animations[x][2];\n        if (STATE === CHANGE) {\n            setTimeout(() => {\n                changeColor(VALUE_1, PURPLE);\n                changeColor(VALUE_2, RED);\n            }, x * ANIMATION_SPEED);\n        }\n        else if (STATE === REVERT) {\n            setTimeout(() => {\n                changeColor(VALUE_1, ACC);\n                changeColor(VALUE_2, ACC);\n            }, x * ANIMATION_SPEED);\n        }\n        else if (STATE === SWAP_CHANGE) {\n            setTimeout(() => {\n                changeColor(VALUE_1, GREEN);\n                changeColor(VALUE_2, GREEN);\n                changeHeight(VALUE_1, mainArray[VALUE_1]);\n                changeHeight(VALUE_2, mainArray[VALUE_2]);\n            }, x * ANIMATION_SPEED);\n        }\n        else {\n            setTimeout(() => {\n                changeColor(VALUE_1, ACC);\n                changeColor(VALUE_2, ACC);\n            }, x * ANIMATION_SPEED);\n        }\n    }\n}\n\n\n// =========================================== ENTRY POINT\nexport default function SelectionSort(\n    nums: number[],\n    speed: number,\n    descending: boolean,\n    callback: Function,\n    returnFrames?: boolean)\n{\n    mainArray = new Array(nums.length)\n    mainArray = Object.assign([], nums)\n\n    ANIMATION_SPEED = 200 - speed;\n    animations = [];\n\n    // act ual algo\n    let size = mainArray.length\n    var i: number, j: number, min_idx: number;\n\n    for (i = 0; i < size - 1; i++)\n    {\n        min_idx = i;\n\n        for (j = i + 1; j < size; j++) {\n            \n            animations.push([CHANGE, j, min_idx])\n            animations.push([REVERT, j, min_idx])\n            if (descending) {\n                if (mainArray[j] > mainArray[min_idx]) min_idx = j;\n            }\n            else {\n                if (mainArray[j] < mainArray[min_idx]) min_idx = j;\n            }\n        }\n        animations.push([SWAP_CHANGE, i, min_idx])\n        animations.push([SWAP_REVERT, i, min_idx])\n\n        const temp = mainArray[min_idx]\n        mainArray[min_idx] = mainArray[i]\n        mainArray[i] = temp;\n    }\n    // animations start\n    if (returnFrames) return animations;\n    animate();\n    callback(animations.length)    \n}\n\nexport function BubbleSort(\n    nums: number[],\n    speed: number,\n    descending: boolean,\n    callback: Function,\n    returnFrames?: boolean)\n{\n    mainArray = new Array(nums.length)\n    mainArray = Object.assign([], nums)\n\n    ANIMATION_SPEED = 200 - speed;\n    animations = [];\n\n    // act ual algo\n    let size = mainArray.length\n\n    for (let i = 0; i < size - 1; i++)\n    {\n        for (let j = i + 1; j < size; j++) {\n\n            animations.push([CHANGE, i, j])\n            animations.push([REVERT, i, j])\n\n            if (!descending) {\n                if (mainArray[i] > mainArray[j]) {\n                    animations.push([SWAP_CHANGE, i, j])        \n                    animations.push([SWAP_REVERT, i, j])  \n                    const temp = mainArray[i]      \n                    mainArray[i] = mainArray[j]\n                    mainArray[j] = temp;\n                }\n            }\n            else {\n                if (mainArray[i] < mainArray[j]) {\n                    animations.push([SWAP_CHANGE, i, j])        \n                    animations.push([SWAP_REVERT, i, j])   \n                    const temp = mainArray[i]     \n                    mainArray[i] = mainArray[j]\n                    mainArray[j] = temp;\n                }\n            }\n        }\n    }\n    // animations start\n    if (returnFrames) return animations;\n    animate();\n    callback(animations.length)    \n}","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\searching\\searchingAlgorithms.tsx",["130","131"],"let FOUND = 1;\nlet CHANGE_COLOR = 0;\nlet REVERT_COLOR = -1;\n\ninterface Frame {\n   state: number, // the options are the variables above\n   lookupIndex: number, // the index in the array\n   steps: number // steps it takes to find\n}\n\nlet LINEAR_SEARCH_ANIMATIONS = [] as Frame[];\nlet BINARY_SEARCH_ANIMATIONS = [] as Frame[];\n\nexport default function getAnimations(array: number[], searchItem: number) {\n   // call this first...\n   resetAnimations();\n   fill_LinearAnimationFrames(array, searchItem);\n   fill_BinaryAnimationFrames(array, searchItem);\n\n   return [\n      LINEAR_SEARCH_ANIMATIONS,\n      BINARY_SEARCH_ANIMATIONS\n   ];\n}\n\nfunction resetAnimations() {\n   LINEAR_SEARCH_ANIMATIONS = []\n   BINARY_SEARCH_ANIMATIONS = []\n}\n\n// -----> fill linear animation frams\nfunction fill_LinearAnimationFrames(array: number[], searchItem: number) {\n   for (let x = 0; x < array.length; x++) {\n      let newFrame: Frame;\n      if (array[x] == searchItem) {\n         newFrame = {\n            state: FOUND,\n            lookupIndex: x, // the index where the saerchItem were found\n            steps: x + 1 // the steps it takes two find the searchItem\n         }\n         LINEAR_SEARCH_ANIMATIONS.push(newFrame);\n         // FOR DEBUGGING PURPOSES\n         // alert(`${searchItem} has been found at index ${x}`)\n         return;\n      }\n      else {\n         // push a frame where that indicates to change color\n         newFrame = {\n            state: CHANGE_COLOR,\n            lookupIndex: x, // current index where we look at\n            steps: x + 1\n         }\n         LINEAR_SEARCH_ANIMATIONS.push(newFrame);\n         // here we need to push another one to change the color back to normal\n         newFrame = {\n            state: REVERT_COLOR,\n            lookupIndex: x, // current index where we look at\n            steps: x + 1\n         }\n         LINEAR_SEARCH_ANIMATIONS.push(newFrame);\n      }\n   }\n}\n\n// -----> BINARY SEARCH\nfunction fill_BinaryAnimationFrames(array: number[], searchItem: number) {\n   let sortedArray = new Array(array.length);\n   sortedArray = Object.assign([], array);\n   sortedArray = sortedArray.sort((a: number, b: number) => a - b);\n   // console.log(searchItem)\n   // console.log(sortedArray)\n   binSearch(\n      sortedArray,\n      searchItem,\n      0,\n      sortedArray.length - 1,\n      0\n   )\n}\n\nfunction binSearch(\n   sortedArray: number[],\n   searchItem: number,\n   lowerBound: number,\n   upperBound: number,\n   NoOfSteps: number): number {\n\n   if (lowerBound > upperBound) return -1;\n\n   NoOfSteps += 1;\n   let midIndex = (upperBound + lowerBound + 1) / 2;\n   midIndex = Math.floor(midIndex);\n   let midElement = sortedArray[midIndex];\n\n   let newFrame: Frame;\n\n   if (midElement == searchItem) {\n      newFrame = {\n         state: FOUND,\n         lookupIndex: midIndex,\n         steps: NoOfSteps\n      }\n      BINARY_SEARCH_ANIMATIONS.push(newFrame);\n      // FOR DEBUGGING PURPOSES\n      // alert(`found at index ${midIndex}`)\n      return midIndex;\n   }\n   // if not the middle check the lower bound\n   // if the searchItem is less than mid Element\n   newFrame = {\n      state: CHANGE_COLOR,\n      lookupIndex: midIndex,\n      steps: NoOfSteps\n   }\n   BINARY_SEARCH_ANIMATIONS.push(newFrame);\n   newFrame = {\n      state: REVERT_COLOR,\n      lookupIndex: midIndex,\n      steps: NoOfSteps\n   }\n   BINARY_SEARCH_ANIMATIONS.push(newFrame);\n\n   if (searchItem < midElement) {\n      return binSearch(\n         sortedArray,\n         searchItem,\n         lowerBound,\n         midIndex - 1,\n         NoOfSteps\n      )\n   }\n   // otherwise\n   return binSearch(\n      sortedArray,\n      searchItem,\n      midIndex + 1,\n      upperBound,\n      NoOfSteps\n   )\n}","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\buttons\\ButtonText.tsx",[],"C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\pathFinding\\NodeSquare.tsx",["132","133","134"],"import { memo, useState, useContext, useEffect, useRef } from 'react';\nimport { mouseDownContext } from './PathFindingVisualizer';\n\nfunction NodeSquare(props: any) {\n    const mouseIsDown = useContext(mouseDownContext);\n    const [start, set_start] = useState(props.isStart);\n    const [finish, set_finish] = useState(props.isFinish);\n    const classname = start ? 'node start' : (finish ? 'node finish' : 'node');\n\n    let box = (document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>);\n\n    useEffect(() => {\n        box = (document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>);\n        props.clearPath();\n        props.onMouseEnter(mouseIsDown.s, props.id, true);\n    }, [finish]);\n\n    useEffect(() => {\n        box = (document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>);\n        props.clearPath();\n        props.onMouseEnter(props.id, mouseIsDown.f, true);\n    }, [start]);\n\n    // @@@@@@@@@@@@@@@@ functions @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2\n    function handleMouseDown(e: any) {\n        if (start || finish) return;\n        e.preventDefault();\n        box = (document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>);\n        let obs = box[props.id].classList.contains('obstacle');\n        if (e.ctrlKey) {\n            const weighted = box[props.id].classList.contains('weight');\n            if (weighted) box[props.id].classList.remove('weight');\n            else box[props.id].classList.add('weight');\n        }\n        else {\n            if (obs) box[props.id].classList.remove('obstacle');\n            else box[props.id].classList.add('obstacle');\n        }\n\n        props.clearPath();\n        props.onMouseEnter(mouseIsDown.s, mouseIsDown.f, true);\n        props.onMouseDown(true);\n    }\n\n    function handleMouseEnter(e: any) {\n        e.preventDefault();\n        if (start || finish) return;\n        if (mouseIsDown.MouseDown) {\n            box = (document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>);\n            let obs = box[props.id].classList.contains('obstacle');\n            if (e.ctrlKey) {\n                const weighted = box[props.id].classList.contains('weight');\n                if (weighted) box[props.id].classList.remove('weight');\n                else box[props.id].classList.add('weight');\n            }\n            else {\n                if (obs) box[props.id].classList.remove('obstacle');\n                else box[props.id].classList.add('obstacle');\n            }\n            props.clearPath();\n            props.onMouseEnter(mouseIsDown.s, mouseIsDown.f, true);\n        }\n    }\n    function handleMouseUp() {\n        props.onMouseDown(false);\n        if(mouseIsDown.prev === props.id) {\n            console.log(box[props.id]);\n            console.log(box[props.id + 1]);\n        }\n    }\n    function handleDragStart(e: any) {\n        box[props.id].setAttribute('draggable', 'false');\n        props.changePrev(props.id);\n    }\n    function handleOnDrop(e: any) {\n        e.preventDefault();\n        if (box[mouseIsDown.prev].classList[1] === 'start') {\n            box[props.id].classList.add('start');\n            box[mouseIsDown.prev].classList.remove('start');\n            props.changeStart(props.id);\n            set_start(true);\n        }\n        else if (box[mouseIsDown.prev].classList[1] === 'finish') {\n            box[props.id].classList.add('finish');\n            box[mouseIsDown.prev].classList.remove('finish');\n            props.changeFinish(props.id);\n            set_finish(true);\n        }\n        box[props.id].setAttribute('draggable', 'true');\n    }\n    function handleDragOver(e: any) {\n        e.preventDefault();\n    }\n    // @@@@@@@@@@@@@@@@@@@@ mark up @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    return (\n        <div\n            onDragOver={handleDragOver}\n            onDrop={handleOnDrop}\n            onDragStart={handleDragStart}\n            onMouseEnter={handleMouseEnter}\n            onMouseDown={handleMouseDown}\n            onMouseUp={handleMouseUp}\n            draggable={start || finish}\n            className={classname}\n            id={props.id}>\n        </div>\n    )\n}\nexport default memo(NodeSquare);","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\pathFinding\\Algorithms.tsx",["135"],"import {dijkstra} from './dijkstra';\n\nconst min = 0;\nconst max = (50 * 15) - 1;\nconst BFS = 0;\nconst DFS = 1;\nconst DIJKSTRA = 2;\n\nlet animationFrames = [] as any;\n\nexport class node {\n    data: number;\n    parent?: node;\n    constructor(value: number) {\n        this.data = value;\n        this.parent = undefined;\n    }\n}\nexport default function Algorithms(start: number, end: number, animationId: number) {\n\n    animationFrames = [];\n    let pathAnimation = [] as any;\n    let pathStart;\n    if (animationId === BFS) pathStart = bfs(start, end);\n    else if (animationId === DFS) pathStart = bfs(start, end, true);\n    else if (animationId === DIJKSTRA) {\n        let frames = dijkstra(start, end);\n        return frames;\n    }\n\n    pathStart = pathStart?.parent;\n\n    while (pathStart != undefined) {\n        pathAnimation.push(pathStart.data);\n        pathStart = pathStart.parent;\n    }\n    return [animationFrames, pathAnimation];\n}\n\n\nexport function bfs(start: number, end: number, depth?: boolean) {\n    let boxes = (document.getElementsByClassName('node') as HTMLCollectionOf<HTMLElement>);\n    let visited = new Set<number>();\n    visited.add(start);\n    let startNode = new node(start);\n    let queue = [] as node[];\n    queue.push(startNode);\n\n    while (queue.length > 0) {\n        let front;\n        if (depth) front = queue.pop();\n        else front = queue.shift();\n        if (front?.data === end) {\n            return front;\n        }\n        else if (front) {\n            const data = front.data;\n            const right = data + 1;\n            const down = data + 50;\n            const up = data - 50;\n            const left = data - 1;\n            if (left >= min && !visited.has(left) && !boxes[left].classList.contains('obstacle')) {\n                visited.add(left);\n                let newNode = new node(left);\n                newNode.parent = front;\n                queue.push(newNode);\n                animationFrames.push(left);\n            }\n            if (right < max && !visited.has(right) && !boxes[right].classList.contains('obstacle')) {\n                visited.add(right);\n                let newNode = new node(right);\n                newNode.parent = front;\n                queue.push(newNode);\n                animationFrames.push(right);\n            }\n            if (down < max && !visited.has(down) && !boxes[down].classList.contains('obstacle')) {\n                visited.add(down);\n                let newNode = new node(down);\n                newNode.parent = front;\n                queue.push(newNode);\n                animationFrames.push(down);\n            }\n            if (up >= min && !visited.has(up) && !boxes[up].classList.contains('obstacle')) {\n                visited.add(up);\n                let newNode = new node(up);\n                newNode.parent = front;\n                queue.push(newNode);\n                animationFrames.push(up);\n            }\n        }\n    }\n}","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\buttons\\ButtonAccent.tsx",[],"C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\buttons\\ToggleButton.tsx",[],"C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\inputs\\TextField.tsx",[],"C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\buttons\\Button.tsx",[],"C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\inputs\\slider.tsx",[],"C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\sortingAlgorithms\\MergeSort.tsx",["136","137"],"import { changeColor, changeHeight, PURPLE, ACC } from './template.functions';\nlet arr = [] as number[];\n// this will be updated using the props\nlet ANIMATION_SPEED = 40;\nlet descend = false;\n// containers of Animation Sequence\nlet animations = [] as any;\n// The function below is where the animation happens\n// the sequence divided for every triplet\n// the first of the triplet is when the values are being compared thus changing its color\n// the second of the tripled is when the values compared and revert its original color\n// you can better notice that in smaller array\n// finally, the third of the triplet is where the changing the height of a bar\n\n// ======================== ANIMATE =======================\nfunction animate() {\n   for (let x = 0; x < animations.length; x++) {\n      // change the color if the current iteration is not the third of the triplet\n      // example 1: if x = 0 then x % 3 = 0 and not 2 then change the color.\n      // example 2: if x = 1 then x % 3 = 0 and not 2 then revert the original color.\n      // example 3: if x = 2 then x % 3 = 2 then change the size;\n      const isColorChange = x % 3 !== 2;\n      if (isColorChange) {\n         const color = x % 3 === 0 ? PURPLE : ACC;\n         setTimeout(() => {\n            changeColor(animations[x][0], color);\n            changeColor(animations[x][1], color);\n\n         }, x * ANIMATION_SPEED);\n      }\n      // else change the height\n      else {\n         setTimeout(() => {\n            changeHeight(animations[x][0], animations[x][1]);\n         }, (x) * (ANIMATION_SPEED));\n      }\n   }\n}\n// ======================== entry point =======================\nexport default function MergeSort(nums: number[], speed: number, descending: boolean, callback: Function, returnFrames?: boolean) {\n   ANIMATION_SPEED = 200 - speed;\n   descend = descending;\n   animations = [];\n   arr = Object.assign([], nums);\n   // call the actual merge Sort to push all the animations\n   divide(0, arr.length - 1);\n\n   if (returnFrames) return animations;\n\n   // actual animation\n   animate();\n   callback(animations.length)\n}\n\n// ====================== MERGE SORT DIVIDE ============================\nfunction divide(left: number, right: number) {\n   if (left >= right)\n      return;\n   const mid = Math.floor((right + left) / 2)\n   // left half\n   divide(left, mid)\n   // right helf\n   divide(mid + 1, right)\n   // merge left and right\n   merge(left, mid, right);\n}\n// ====================== MERGE SORT COMBINE ============================\nfunction merge(left: number, mid: number, right: number) {\n   const leftsize = mid - left + 1;\n   const rightsize = right - mid;\n   const leftsub = arr.slice(left, mid + 1);\n   const rightsub = arr.slice(mid + 1);\n   let i = 0;\n   let j = 0;\n   let k = left;\n   while (i < leftsize && j < rightsize) {\n      // push two animations for color changes\n      animations.push([k, (left + leftsize) + j]);\n      // push the second time to revert the color\n      animations.push([k, (left + leftsize) + j]);\n      if (descend) {\n         if (leftsub[i] > rightsub[j]) {\n            // push the Height changes\n            animations.push([k, leftsub[i]]);\n            arr[k] = leftsub[i];\n            i++; k++;\n         }\n         else {\n            // push the Height changes\n            animations.push([k, rightsub[j]]);\n            arr[k] = rightsub[j];\n            j++; k++;\n         }\n         continue;\n      }\n      if (leftsub[i] < rightsub[j]) {\n         // push the Height changes\n         animations.push([k, leftsub[i]]);\n         arr[k] = leftsub[i];\n         i++; k++;\n      }\n      else {\n         // push the Height changes\n         animations.push([k, rightsub[j]]);\n         arr[k] = rightsub[j];\n         j++; k++;\n      }\n   }\n   while (i < leftsize) {\n      // here we should push a TRIPLET to maintain the ratio of the animatino sequence\n      animations.push([left + i, left + i]);\n      animations.push([left + i, left + i]);\n      animations.push([k, leftsub[i]]);\n\n      arr[k] = leftsub[i];\n      i++;\n      k++;\n   }\n\n   while (j < rightsize) {\n      animations.push([right + j, right + j]);\n      animations.push([right + j, right + j]);\n      animations.push([k, rightsub[j]]);\n\n      arr[k] = rightsub[j];\n      j++;\n      k++;\n   }\n}\n","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\sortingAlgorithms\\QuickSort.tsx",["138"],"// `\n// ANIMATION STRATEGY: \n//     Each iteraton in animations array is also an array\n//     that has 3 elements. \n// Examples:\n//      [CHANGE, index, pivot],\n//      [REVERT, index, pivot],\n//      [SWAP_CHANGE, index1, index2],\n//      [SWAP_REVERT, index1, index2]\n// Basically, this means that if we found a CHANGE,\n// we will change the color of the bars[index],\n// if we found a REVERT then change its color back to normal,\n// if SWAP_CHANGE, change their colors and swap. \n// That means that the height of bars[inde1] will be the \n// height of bars[index2] and vice versa.\n// Finally, if we found SWAP_REVERT we will just simply \n// change the color back to normal\n// `\n\nimport {\n    changeColor,\n    changeHeight,\n    PURPLE,\n    RED,\n    GREEN,\n    ACC\n} from './template.functions';\n\n//  ======================================== DEPENDENT  VARIABLES <<<\nlet mainArray = [] as number[];\n// this will be updated using the props\nlet ANIMATION_SPEED = 40;\n// containers of Animation Sequence\nlet animations = [] as any;\nlet isDescending = false;\n\n// ========================================= INDEPENDENT VARIABLES\n// this will be use for identifyig \n// animation sequences\nconst CHANGE = \"change\";\nconst REVERT = \"revert\";\nconst SWAP_CHANGE = \"swap_change\";\nconst SWAP_REVERT = \"swap_revert\";\n\n// ==================================================== ANIMATION animate()\nfunction animate() {\n    for (let x = 0; x < animations.length; x++) {\n        const STATE = animations[x][0];\n        const VALUE_1 = animations[x][1];\n        const VALUE_2 = animations[x][2];\n        if (STATE === CHANGE) {\n            setTimeout(() => {\n                changeColor(VALUE_1, PURPLE);\n                changeColor(VALUE_2, RED);\n            }, x * ANIMATION_SPEED);\n        }\n        else if (STATE === REVERT) {\n            setTimeout(() => {\n                changeColor(VALUE_1, ACC);\n                changeColor(VALUE_2, ACC);\n            }, x * ANIMATION_SPEED);\n        }\n        else if (STATE === SWAP_CHANGE) {\n            setTimeout(() => {\n                changeColor(VALUE_1, GREEN);\n                changeColor(VALUE_2, GREEN);\n                changeHeight(VALUE_1, mainArray[VALUE_1]);\n                changeHeight(VALUE_2, mainArray[VALUE_2]);\n            }, x * ANIMATION_SPEED);\n        }\n        else {\n            setTimeout(() => {\n                changeColor(VALUE_1, ACC);\n                changeColor(VALUE_2, ACC);\n            }, x * ANIMATION_SPEED);\n        }\n    }\n}\n\n// ===================================================== PARTITION DESCENDING\nfunction partition_descending(left: number, right: number, PIVOT: number) {    \n    while (left <= right) {\n        // here we will push the animation comparision\n        // example: animation.comparision.push([left, right])\n        // because we are comparing left and right\n        while (mainArray[left] > PIVOT){\n            animations.push([\n                CHANGE,\n                left,\n                PIVOT\n            ])\n            animations.push([\n                REVERT,\n                left,\n                PIVOT\n            ])\n            left++;\n        }\n        while (mainArray[right] < PIVOT){\n            animations.push([\n                CHANGE,\n                right,\n                PIVOT\n            ])\n            animations.push([\n                REVERT,\n                right,\n                PIVOT\n            ])\n            right--; \n        }\n        if (left <= right) {\n            animations.push([\n                SWAP_CHANGE,\n                left,\n                right\n            ])\n            animations.push([\n                SWAP_REVERT,\n                left,\n                right\n            ])\n            // here I'm swapping left and aright\n            let temporary = mainArray[left];\n            mainArray[left] = mainArray[right];\n            mainArray[right] = temporary;\n\n            left++;\n            right--;\n        }\n    }\n    return left;\n}\n\n// ===================================================== PARTITION ASCENDING\nfunction partition_ascending(left: number, right: number, PIVOT: number) {    \n    while (left <= right) {\n        // here we will push the animation comparision\n        // example: animations.comparision.push([left, right])\n        // because we are comparing left and right\n        while (mainArray[left] < PIVOT) {\n            animations.push([\n                CHANGE,\n                left,\n                PIVOT\n            ])\n            animations.push([\n                REVERT,\n                left,\n                PIVOT\n            ])\n            left++;\n        }\n            \n        while (mainArray[right] > PIVOT) {\n            animations.push([\n                CHANGE,\n                right,\n                PIVOT\n            ])\n            animations.push([\n                REVERT,\n                right,\n                PIVOT\n            ])\n            right--; \n        }\n               \n        if (left <= right) {\n            animations.push([\n                SWAP_CHANGE,\n                left,\n                right\n            ])\n            animations.push([\n                SWAP_REVERT,\n                left,\n                right\n            ])\n            // here I'm swapping left and aright\n            let temporary = mainArray[left];\n            mainArray[left] = mainArray[right];\n            mainArray[right] = temporary;\n            left++;\n            right--;\n        }\n    }\n    return left;\n}\n\n// ===================================================== SORT\nfunction sort(left: number, right: number) {\n    if (left >= right)\n        return;\n    // here I choose the middle element as a PIVOT\n    let midIndex = (left + right) / 2;\n    // console.log(midIndex);\n    // make sure to always floor the mid to avoid infinite loop\n    midIndex = Math.floor(midIndex);\n    let PIVOT = mainArray[midIndex];\n    // here, partition should return the index of the pivot \n    // or the element that is already in correct position\n    let DIVIDING_POINT: number;\n    if(isDescending)\n        DIVIDING_POINT = partition_descending(left, right, PIVOT);\n    else\n        DIVIDING_POINT = partition_ascending(left, right, PIVOT);\n    sort(left, DIVIDING_POINT - 1);\n    sort(DIVIDING_POINT, right);\n}\n\n// ================================================== ENTRY POINT\nexport default function QuickSort(\n    numbers: number[],\n    speed: number,\n    descending: boolean,\n    callback: Function,\n    returnFrames?: boolean)\n{\n    ANIMATION_SPEED = 200 - speed;\n    isDescending = descending;  \n    mainArray = Object.assign([], numbers);\n    // always clear the animations \n    animations = [];\n    // ACTUAL QUICK SORT CALL\n\n    sort(0, mainArray.length - 1);\n    if (returnFrames) return animations;\n    animate();\n    callback(animations.length);\n}","C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\sortingAlgorithms\\template.functions.ts",[],"C:\\Users\\tanus\\Desktop\\Algo Visualizer\\src\\components\\visualizers\\pathFinding\\dijkstra.tsx",[],["139","140"],{"ruleId":"141","replacedBy":"142"},{"ruleId":"143","replacedBy":"144"},{"ruleId":"145","severity":1,"message":"146","line":21,"column":21,"nodeType":"147","messageId":"148","endLine":21,"endColumn":32},{"ruleId":"149","severity":1,"message":"150","line":29,"column":7,"nodeType":"151","endLine":29,"endColumn":20,"suggestions":"152"},{"ruleId":"145","severity":1,"message":"153","line":145,"column":11,"nodeType":"147","messageId":"148","endLine":145,"endColumn":15},{"ruleId":"154","severity":1,"message":"155","line":81,"column":30,"nodeType":"156","messageId":"157","endLine":81,"endColumn":32},{"ruleId":"145","severity":1,"message":"158","line":8,"column":21,"nodeType":"147","messageId":"148","endLine":8,"endColumn":24},{"ruleId":"145","severity":1,"message":"159","line":8,"column":26,"nodeType":"147","messageId":"148","endLine":8,"endColumn":30},{"ruleId":"149","severity":1,"message":"160","line":26,"column":8,"nodeType":"151","endLine":26,"endColumn":10,"suggestions":"161"},{"ruleId":"149","severity":1,"message":"162","line":51,"column":8,"nodeType":"151","endLine":51,"endColumn":35,"suggestions":"163"},{"ruleId":"164","severity":1,"message":"165","line":43,"column":24,"nodeType":"166","messageId":"167","endLine":48,"endColumn":14},{"ruleId":"164","severity":1,"message":"165","line":65,"column":24,"nodeType":"166","messageId":"167","endLine":70,"endColumn":14},{"ruleId":"164","severity":1,"message":"165","line":43,"column":24,"nodeType":"166","messageId":"167","endLine":48,"endColumn":14},{"ruleId":"164","severity":1,"message":"165","line":43,"column":24,"nodeType":"166","messageId":"167","endLine":48,"endColumn":14},{"ruleId":"154","severity":1,"message":"155","line":35,"column":20,"nodeType":"156","messageId":"157","endLine":35,"endColumn":22},{"ruleId":"154","severity":1,"message":"155","line":97,"column":19,"nodeType":"156","messageId":"157","endLine":97,"endColumn":21},{"ruleId":"145","severity":1,"message":"168","line":1,"column":49,"nodeType":"147","messageId":"148","endLine":1,"endColumn":55},{"ruleId":"149","severity":1,"message":"169","line":13,"column":16,"nodeType":"170","endLine":13,"endColumn":88},{"ruleId":"149","severity":1,"message":"169","line":19,"column":16,"nodeType":"170","endLine":19,"endColumn":88},{"ruleId":"154","severity":1,"message":"171","line":33,"column":22,"nodeType":"156","messageId":"157","endLine":33,"endColumn":24},{"ruleId":"164","severity":1,"message":"172","line":25,"column":21,"nodeType":"166","messageId":"167","endLine":29,"endColumn":11},{"ruleId":"164","severity":1,"message":"172","line":33,"column":21,"nodeType":"166","messageId":"167","endLine":35,"endColumn":11},{"ruleId":"164","severity":1,"message":"165","line":64,"column":24,"nodeType":"166","messageId":"167","endLine":69,"endColumn":14},{"ruleId":"141","replacedBy":"173"},{"ruleId":"143","replacedBy":"174"},"no-native-reassign",["175"],"no-negated-in-lhs",["176"],"@typescript-eslint/no-unused-vars","'setTimeouts' is assigned a value but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'sorted'. Either include it or remove the dependency array.","ArrayExpression",["177"],"'bars' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'bfs' is defined but never used.","'node' is defined but never used.","React Hook useEffect has a missing dependency: 'addBorderWalls'. Either include it or remove the dependency array.",["178"],"React Hook useMemo has a missing dependency: 'findThePath'. Either include it or remove the dependency array.",["179"],"no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'mainArray', 'mainArray'.","ArrowFunctionExpression","unsafeRefs","'useRef' is defined but never used.","Assignments to the 'box' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","TSAsExpression","Expected '!==' and instead saw '!='.","Function declared in a loop contains unsafe references to variable(s) 'animations', 'animations'.",["175"],["176"],"no-global-assign","no-unsafe-negation",{"desc":"180","fix":"181"},{"desc":"182","fix":"183"},{"desc":"184","fix":"185"},"Update the dependencies array to be: [searchArray, sorted]",{"range":"186","text":"187"},"Update the dependencies array to be: [addBorderWalls]",{"range":"188","text":"189"},"Update the dependencies array to be: [findThePath, start, finish]",{"range":"190","text":"191"},[1195,1208],"[searchArray, sorted]",[1029,1031],"[addBorderWalls]",[1899,1926],"[findThePath, start, finish]"]